/*
 * BTree.cc - implementation of methods of class BTree as declared in BTree.h.
 *
 * Several of the methods in this file must be implemented by students for
 * cs222 project 4
 *
 * If this file is compiled with the symbol PROFESSOR_VERSION defined,
 * it expects a file of that name to exist, and uses the code from
 * that file in place of selected dummy methods left to be written by students.
 *
 * Copyright (c) 2001, 2002, 2003 - Russell C. Bjork
 * Trivial changes 2016 - Russ Tuck
 * Edited by Jonathan Manos & Alonzo Ouzts
 */

#include <iostream>
using std::cout;

#include "BTree.h"
#include "BTreeFile.h"
#include "BTreeBlock.h"

BTree::BTree(string name)
: _file(* new BTreeFile(name))
{ }

#ifndef PROFESSOR_VERSION

void BTree::insert(string key, string value)
{

    //Instantiate BlockNumber and BTreeBlock
    BTreeFile::BlockNumber blockNumber = _file.getRoot();
    BTreeBlock currentBlock;
    _file.getBlock(blockNumber, currentBlock);

    int index = 0;

    /*while(blockNumber != 0)
    {

        if(currentBlock.getKey(index) == key)
	{
	    value = currentBlock.getValue(index);
	    return true;
	}
	else
        {
            blockNumber = currentBlock.getChild(index);
	    _file.getBlock(blockNumber, currentBlock);
            index = currentBlock.getPosition(key);
        }
   
    } */


    //If there is no root block, make the root block and insert
    //the given key and value
    
    if(blockNumber == 0)
    {
        std::cout<< "No root found" << std::endl;

	blockNumber = _file.allocateBlock();	
	index = currentBlock.getPosition(key);

	std::cout<< "Inserting key: " << key<< " with value: " << value << " at index: " << index << " in blockNumber: " << blockNumber << std::endl;

        currentBlock.insert(index, key, value, blockNumber);

	currentBlock.setChild(0, 0);
	
        _file.putBlock(blockNumber, currentBlock);  
	_file.setRoot(blockNumber);
    }
    else
    {
        std::cout<< "root found" << std::endl;
	
	index = currentBlock.getPosition(key);

	std::cout<< "Inserting key: " << key<< " with value: " << value << " at index: " << index << " in blockNumber: " << blockNumber << std::endl;

        currentBlock.insert(index, key, value, blockNumber);
	
        _file.putBlock(blockNumber, currentBlock);  
    }    

    std::cout<<"finished inserting"<<std::endl;

}

bool BTree::lookup(string key, string & value) const
{

    //Instantiate BlockNumber and BTreeBlock
    BTreeFile::BlockNumber blockNumber = _file.getRoot();
    BTreeBlock currentBlock;
    _file.getBlock(blockNumber, currentBlock);

    //Set int value as the index of the position of the key
    int index = currentBlock.getPosition(key);

    //While loop that returns true if the currentBlock contains the key
    //and setting the currentBlock to the child at the given index.
    //Loop stops if given blockNumber is 0, meaning there is no block.
    while(blockNumber != 0)
    {

        if(currentBlock.getKey(index) == key)
	{
	    value = currentBlock.getValue(index);
	    return true;
	}
	else
        {
            blockNumber = currentBlock.getChild(index);
	    _file.getBlock(blockNumber, currentBlock);
            index = currentBlock.getPosition(key);
        }
   
    }
    return false;
}

bool BTree::remove(string key)
{
    return false; // Student code goes here - remove this line
}

#else

#define QUOTE(Q) #Q
#define INCLUDE_NAME(X) QUOTE(X)
#include INCLUDE_NAME(PROFESSOR_VERSION)

#endif

void BTree::print() const
{
    cout << "BTree in file ";
    _file.printHeaderInfo();
    cout << endl;

    BTreeFile::BlockNumber root = _file.getRoot();
    if (root == 0)
        cout << "Empty tree" << endl;
    else
        _file.printBlock(root, true, 1);
}

void BTree::print(BTreeFile::BlockNumber blockNumber) const
{
    _file.printBlock(blockNumber, false, 1);
}

BTree::~BTree()
{
    delete (& _file);
}
